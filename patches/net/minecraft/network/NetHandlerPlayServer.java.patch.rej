++++ REJECTED PATCH 7
     private int keepAliveId;
     private long lastPingTime;
     private long lastSentPingPacket;
-    private int chatSpamThresholdCount;
+    //private int chatSpamThresholdCount;
+    // CraftBukkit start - multithreaded fields
+    private volatile int chatSpamThresholdCount;
+    private static AtomicIntegerFieldUpdater<NetHandlerPlayServer> chatSpamField;
+    // CraftBukkit end
     private int itemDropThreshold;
-    private final IntHashMap<Short> pendingTransactions = new IntHashMap();
+    private final IntHashMap<Short> pendingTransactions = new IntHashMap<Short>();
     private double firstGoodX;
     private double firstGoodY;
     private double firstGoodZ;
++++ END PATCH
++++ REJECTED PATCH 8
     private int vehicleFloatingTickCount;
     private int movePacketCounter;
     private int lastMovePacketCounter;
+    private boolean processedDisconnect; // CraftBukkit - Added
+    static { // Svarka
+    	Field[] fileds = NetHandlerPlayServer.class.getDeclaredFields();
+    	for(Field f : fileds) {
+    		String n = f.getName();
+    		if(n.equals("chatSpamThresholdCount") || n.equals("field_147374_l") || n.equals("i")) {
+    			chatSpamField = AtomicIntegerFieldUpdater.newUpdater(NetHandlerPlayServer.class, n);
+    			break;
+    		}
+    	}
+    	assert chatSpamField != null;
+    }
 
     public NetHandlerPlayServer(MinecraftServer server, NetworkManager networkManagerIn, EntityPlayerMP playerIn)
     {
++++ END PATCH
++++ REJECTED PATCH 12
 
         if (this.playerEntity.getLastActiveTime() > 0L && this.serverController.getMaxPlayerIdleMinutes() > 0 && MinecraftServer.getCurrentTimeMillis() - this.playerEntity.getLastActiveTime() > (long)(this.serverController.getMaxPlayerIdleMinutes() * 1000 * 60))
         {
+        	this.playerEntity.markPlayerActive(); // CraftBukkit - SPIGOT-854
             this.kickPlayerFromServer("You have been idle for too long!");
         }
     }
++++ END PATCH
++++ REJECTED PATCH 13
 
     public void kickPlayerFromServer(String reason)
     {
+    	// CraftBukkit start - fire PlayerKickEvent
+    	if (this.processedDisconnect) {
+    		return;
+    	}
+    	String leaveMessage = TextFormatting.YELLOW + this.playerEntity.getName() + " left the game.";
+    	
+    	PlayerKickEvent event = new PlayerKickEvent(this.server.getPlayer(this.playerEntity), reason, leaveMessage);
+    	
+    	if (this.server.getServer().isServerRunning()) {
+    		this.server.getPluginManager().callEvent(event);
+    	}
+    	
+    	if (event.isCancelled()) {
+    		// Do not kick the player
+    		return;
+    	}
+    	// Send the possibly modified leave message
+    	reason = event.getReason();
+    	// CraftBukkit end
         final TextComponentString textcomponentstring = new TextComponentString(reason);
         this.netManager.sendPacket(new SPacketDisconnect(textcomponentstring), new GenericFutureListener < Future <? super Void >> ()
         {
++++ END PATCH
++++ REJECTED PATCH 14
                 NetHandlerPlayServer.this.netManager.closeChannel(textcomponentstring);
             }
         }, new GenericFutureListener[0]);
+        this.onDisconnect(textcomponentstring); //CB
         this.netManager.disableAutoRead();
-        Futures.getUnchecked(this.serverController.addScheduledTask(new Runnable()
-        {
+        //Futures.getUnchecked(this.serverController.addScheduledTask(new Runnable()
+        this.serverController.addScheduledTask((new Runnable() {
             public void run()
             {
                 NetHandlerPlayServer.this.netManager.checkDisconnected();
++++ END PATCH
++++ REJECTED PATCH 17
                     {
                         this.playerEntity.setPositionAndRotation(this.playerEntity.posX, this.playerEntity.posY, this.playerEntity.posZ, packetIn.getYaw(this.playerEntity.rotationYaw), packetIn.getPitch(this.playerEntity.rotationPitch));
                         this.serverController.getPlayerList().serverUpdateMountedMovingPlayer(this.playerEntity);
+                        allowedPlayerTicks = 20; // CB
                     }
                     else
                     {
-                        double d0 = this.playerEntity.posX;
-                        double d1 = this.playerEntity.posY;
-                        double d2 = this.playerEntity.posZ;
-                        double d3 = this.playerEntity.posY;
-                        double d4 = packetIn.getX(this.playerEntity.posX);
-                        double d5 = packetIn.getY(this.playerEntity.posY);
-                        double d6 = packetIn.getZ(this.playerEntity.posZ);
-                        float f = packetIn.getYaw(this.playerEntity.rotationYaw);
-                        float f1 = packetIn.getPitch(this.playerEntity.rotationPitch);
-                        double d7 = d4 - this.firstGoodX;
-                        double d8 = d5 - this.firstGoodY;
-                        double d9 = d6 - this.firstGoodZ;
+                    	// CraftBukkit - Make sure the move is valid but then reset it for plugins to modify
+                        double prevX = playerEntity.posX;
+                        double prevY = playerEntity.posY;
+                        double prevZ = playerEntity.posZ;
+                        float prevYaw = playerEntity.rotationYaw;
+                        float prevPitch = playerEntity.rotationPitch;
+                        // CraftBukkit end
+                        double xprevv = this.playerEntity.posX;
+                        double yprevv = this.playerEntity.posY;
+                        double zprevv = this.playerEntity.posZ;
+                        double y2 = this.playerEntity.posY;
+                        double px = packetIn.getX(this.playerEntity.posX);
+                        double py = packetIn.getY(this.playerEntity.posY);
+                        double pz = packetIn.getZ(this.playerEntity.posZ);
+                        float pyaw = packetIn.getYaw(this.playerEntity.rotationYaw);
+                        float ppitch = packetIn.getPitch(this.playerEntity.rotationPitch);
+                        double mx = px - this.firstGoodX;
+                        double my = py - this.firstGoodY;
+                        double mz = pz - this.firstGoodZ;
                         double d10 = this.playerEntity.motionX * this.playerEntity.motionX + this.playerEntity.motionY * this.playerEntity.motionY + this.playerEntity.motionZ * this.playerEntity.motionZ;
-                        double d11 = d7 * d7 + d8 * d8 + d9 * d9;
+                        double moveFromLastTick = mx * mx + my * my + mz * mz;
                         ++this.movePacketCounter;
-                        int i = this.movePacketCounter - this.lastMovePacketCounter;
+                        int recPcts = this.movePacketCounter - this.lastMovePacketCounter;
 
-                        if (i > 5)
-                        {
-                            LOGGER.debug("{} is sending move packets too frequently ({} packets since last tick)", new Object[] {this.playerEntity.getName(), Integer.valueOf(i)});
-                            i = 1;
-                        }
+                        //if (i > 5)
+                        //{
+                        //    LOGGER.debug("{} is sending move packets too frequently ({} packets since last tick)", new Object[] {this.playerEntity.getName(), Integer.valueOf(i)});
+                        // CraftBukkit start - handle custom speeds and skipped ticks
+                        this.allowedPlayerTicks += (System.currentTimeMillis() / 50) - this.lastTick;
+                        this.allowedPlayerTicks = Math.max(this.allowedPlayerTicks, 1);
+                        this.lastTick = (int) (System.currentTimeMillis() / 50);
 
+                        if (recPcts > Math.max(this.allowedPlayerTicks, 5)) {
+                        	recPcts = 1;
+                        }
+                        
+                        if (packetIn.rotating || moveFromLastTick > 0) {
+                            allowedPlayerTicks -= 1;
+                        } else {
+                            allowedPlayerTicks = 20;
+                        }
+                        float speed;
+                        if (playerEntity.capabilities.isFlying) {
+                            speed = playerEntity.capabilities.flySpeed * 20f;
+                        } else {
+                            speed = playerEntity.capabilities.walkSpeed * 10f;
+                        }
                         if (!this.playerEntity.isInvulnerableDimensionChange() && (!this.playerEntity.getServerWorld().getGameRules().getBoolean("disableElytraMovementCheck") || !this.playerEntity.isElytraFlying()))
                         {
                             float f2 = this.playerEntity.isElytraFlying() ? 300.0F : 100.0F;
 
-                            if (d11 - d10 > (double)(f2 * (float)i) && (!this.serverController.isSinglePlayer() || !this.serverController.getServerOwner().equals(this.playerEntity.getName())))
+                            if (moveFromLastTick - d10 > /*(double)(f2 * (float)i)*/Math.max(100, Math.pow((double) (10.0F * (float) recPcts * speed), 2)) && (!this.serverController.isSinglePlayer() || !this.serverController.getServerOwner().equals(this.playerEntity.getName())))
                             {
-                                LOGGER.warn("{} moved too quickly! {},{},{}", new Object[] {this.playerEntity.getName(), Double.valueOf(d7), Double.valueOf(d8), Double.valueOf(d9)});
+                            	// CB end
+                                LOGGER.warn("{} moved too quickly! {},{},{}", new Object[] {this.playerEntity.getName(), Double.valueOf(mx), Double.valueOf(my), Double.valueOf(mz)});
                                 this.setPlayerLocation(this.playerEntity.posX, this.playerEntity.posY, this.playerEntity.posZ, this.playerEntity.rotationYaw, this.playerEntity.rotationPitch);
                                 return;
                             }
                         }
 
                         boolean flag2 = worldserver.getCollisionBoxes(this.playerEntity, this.playerEntity.getEntityBoundingBox().contract(0.0625D)).isEmpty();
-                        d7 = d4 - this.lastGoodX;
-                        d8 = d5 - this.lastGoodY;
-                        d9 = d6 - this.lastGoodZ;
+                        mx = px - this.lastGoodX;
+                        my = py - this.lastGoodY;
+                        mz = pz - this.lastGoodZ;
 
-                        if (this.playerEntity.onGround && !packetIn.isOnGround() && d8 > 0.0D)
+                        if (this.playerEntity.onGround && !packetIn.isOnGround() && my > 0.0D)
                         {
                             this.playerEntity.jump();
                         }
 
-                        this.playerEntity.moveEntity(d7, d8, d9);
+                        this.playerEntity.moveEntity(mx, my, mz);
                         this.playerEntity.onGround = packetIn.isOnGround();
-                        double d12 = d8;
-                        d7 = d4 - this.playerEntity.posX;
-                        d8 = d5 - this.playerEntity.posY;
+                        double d12 = my;
+                        mx = px - this.playerEntity.posX;
+                        my = py - this.playerEntity.posY;
+                        mz = pz - this.playerEntity.posZ;
 
-                        if (d8 > -0.5D || d8 < 0.5D)
+                        if (my > -0.5D || my < 0.5D)
                         {
-                            d8 = 0.0D;
+                            my = 0.0D;
                         }
 
-                        d9 = d6 - this.playerEntity.posZ;
-                        d11 = d7 * d7 + d8 * d8 + d9 * d9;
+                        moveFromLastTick = mx * mx + my * my + mz * mz;
                         boolean flag = false;
 
-                        if (!this.playerEntity.isInvulnerableDimensionChange() && d11 > 0.0625D && !this.playerEntity.isPlayerSleeping() && !this.playerEntity.interactionManager.isCreative() && this.playerEntity.interactionManager.getGameType() != GameType.SPECTATOR)
+                        if (!this.playerEntity.isInvulnerableDimensionChange() && moveFromLastTick > 0.0625D && !this.playerEntity.isPlayerSleeping() && !this.playerEntity.interactionManager.isCreative() && this.playerEntity.interactionManager.getGameType() != GameType.SPECTATOR)
                         {
                             flag = true;
                             LOGGER.warn("{} moved wrongly!", new Object[] {this.playerEntity.getName()});
                         }
 
-                        this.playerEntity.setPositionAndRotation(d4, d5, d6, f, f1);
-                        this.playerEntity.addMovementStat(this.playerEntity.posX - d0, this.playerEntity.posY - d1, this.playerEntity.posZ - d2);
+                        this.playerEntity.setPositionAndRotation(px, py, pz, pyaw, ppitch);
+                        this.playerEntity.addMovementStat(this.playerEntity.posX - xprevv, this.playerEntity.posY - yprevv, this.playerEntity.posZ - zprevv);
 
                         if (!this.playerEntity.noClip && !this.playerEntity.isPlayerSleeping())
                         {
++++ END PATCH
++++ REJECTED PATCH 18
 
                             if (flag2 && (flag || !flag1))
                             {
-                                this.setPlayerLocation(d0, d1, d2, f, f1);
+                                this.setPlayerLocation(xprevv, yprevv, zprevv, pyaw, ppitch);
                                 return;
                             }
                         }
+                        
+                        // CraftBukkit start - fire PlayerMoveEvent
+                        // Rest to old location first
+                        this.playerEntity.setLocationAndAngles(prevX, prevY, prevZ, prevYaw, prevPitch);
 
+                        Player player = this.getPlayer();
+                        Location from = new Location(player.getWorld(), lastPosX, lastPosY, lastPosZ, lastYaw, lastPitch); // Get the Players previous Event location.
+                        Location to = player.getLocation().clone(); // Start off the To location as the Players current location.
+
+                        // If the packet contains movement information then we update the To location with the correct XYZ.
+                        if (packetIn.moving) {
+                            to.setX(packetIn.x);
+                            to.setY(packetIn.y);
+                            to.setZ(packetIn.z);
+                        }
+
+                        // If the packet contains look information then we update the To location with the correct Yaw & Pitch.
+                        if (packetIn.rotating) {
+                            to.setYaw(packetIn.yaw);
+                            to.setPitch(packetIn.pitch);
+                        }
+
+                        // Prevent 40 event-calls for less than a single pixel of movement >.>
+                        double delta = Math.pow(this.lastPosX - to.getX(), 2) + Math.pow(this.lastPosY - to.getY(), 2) + Math.pow(this.lastPosZ - to.getZ(), 2);
+                        float deltaAngle = Math.abs(this.lastYaw - to.getYaw()) + Math.abs(this.lastPitch - to.getPitch());
+
+                        if ((delta > 1f / 256F || deltaAngle > 5f) && !this.playerEntity.isMovementBlockedCB()) {
+                            this.lastPosX = to.getX();
+                            this.lastPosY = to.getY();
+                            this.lastPosZ = to.getZ();
+                            this.lastYaw = to.getYaw();
+                            this.lastPitch = to.getPitch();
+
+                            // Skip the first time we do this
+                            if (from.getX() != Double.MAX_VALUE) {
+                                Location oldTo = to.clone();
+                                PlayerMoveEvent event = new PlayerMoveEvent(player, from, to);
+                                this.server.getPluginManager().callEvent(event);
+
+                                // If the event is cancelled we move the player back to their old location.
+                                if (event.isCancelled()) {
+                                    teleport(from);
+                                    return;
+                                }
+
+                                // If a Plugin has changed the To destination then we teleport the Player
+                                // there to avoid any 'Moved wrongly' or 'Moved too quickly' errors.
+                                // We only do this if the Event was not cancelled.
+                                if (!oldTo.equals(event.getTo()) && !event.isCancelled()) {
+                                    this.playerEntity.getBukkitEntity().teleport(event.getTo(), PlayerTeleportEvent.TeleportCause.UNKNOWN);
+                                    return;
+                                }
+
+                                // Check to see if the Players Location has some how changed during the call of the event.
+                                // This can happen due to a plugin teleporting the player instead of using .setTo()
+                                if (!from.equals(this.getPlayer().getLocation()) && this.justTeleported) {
+                                    this.justTeleported = false;
+                                    return;
+                                }
+                            }
+                        }
+                        this.playerEntity.setLocationAndAngles(px, py, pz, pyaw, ppitch); // Copied from above
+                        // CraftBukkit end
+
                         this.floating = d12 >= -0.03125D;
                         this.floating &= !this.serverController.isFlightAllowed() && !this.playerEntity.capabilities.allowFlying;
                         this.floating &= !this.playerEntity.isPotionActive(MobEffects.LEVITATION) && !this.playerEntity.isElytraFlying() && !worldserver.checkBlockCollision(this.playerEntity.getEntityBoundingBox().expandXyz(0.0625D).addCoord(0.0D, -0.55D, 0.0D));
                         this.playerEntity.onGround = packetIn.isOnGround();
                         this.serverController.getPlayerList().serverUpdateMountedMovingPlayer(this.playerEntity);
-                        this.playerEntity.handleFalling(this.playerEntity.posY - d3, packetIn.isOnGround());
+                        this.playerEntity.handleFalling(this.playerEntity.posY - y2, packetIn.isOnGround());
                         this.lastGoodX = this.playerEntity.posX;
                         this.lastGoodY = this.playerEntity.posY;
                         this.lastGoodZ = this.playerEntity.posZ;
++++ END PATCH
++++ REJECTED PATCH 19
 
     public void setPlayerLocation(double x, double y, double z, float yaw, float pitch, Set<SPacketPlayerPosLook.EnumFlags> relativeSet)
     {
-        double d0 = relativeSet.contains(SPacketPlayerPosLook.EnumFlags.X) ? this.playerEntity.posX : 0.0D;
-        double d1 = relativeSet.contains(SPacketPlayerPosLook.EnumFlags.Y) ? this.playerEntity.posY : 0.0D;
-        double d2 = relativeSet.contains(SPacketPlayerPosLook.EnumFlags.Z) ? this.playerEntity.posZ : 0.0D;
-        this.targetPos = new Vec3d(x + d0, y + d1, z + d2);
+        //double d0 = relativeSet.contains(SPacketPlayerPosLook.EnumFlags.X) ? this.playerEntity.posX : 0.0D;
+        //double d1 = relativeSet.contains(SPacketPlayerPosLook.EnumFlags.Y) ? this.playerEntity.posY : 0.0D;
+        //double d2 = relativeSet.contains(SPacketPlayerPosLook.EnumFlags.Z) ? this.playerEntity.posZ : 0.0D;
+    	final Player player = this.getPlayer();
+        final Location from = player.getLocation();
+        double x2 = x;
+        double y2 = y;
+        double z2 = z;
+        //this.targetPos = new Vec3d(x + d0, y + d1, z + d2);
         float f = yaw;
         float f1 = pitch;
 
-        if (relativeSet.contains(SPacketPlayerPosLook.EnumFlags.Y_ROT))
-        {
-            f = yaw + this.playerEntity.rotationYaw;
+        if (relativeSet.contains(SPacketPlayerPosLook.EnumFlags.X)) {
+            x2 += from.getX();
         }
-
+        if (relativeSet.contains(SPacketPlayerPosLook.EnumFlags.Y)) {
+            y2 += from.getY();
+        }
+        if (relativeSet.contains(SPacketPlayerPosLook.EnumFlags.Z)) {
+            z2 += from.getZ();
+        }
+        if (relativeSet.contains(SPacketPlayerPosLook.EnumFlags.Y_ROT)) {
+            f += from.getYaw();
+        }
         if (relativeSet.contains(SPacketPlayerPosLook.EnumFlags.X_ROT))
         {
-            f1 = pitch + this.playerEntity.rotationPitch;
+            f1 = from.getPitch();
         }
+        Location to = new Location(this.getPlayer().getWorld(), x2, y2, z2, f, f1);
+        PlayerTeleportEvent event = new PlayerTeleportEvent(player, from.clone(), to.clone(), PlayerTeleportEvent.TeleportCause.UNKNOWN);
+        this.server.getPluginManager().callEvent(event);
+        
+        if (event.isCancelled() || !to.equals(event.getTo())) {
+        	relativeSet.clear(); // Can't relative teleport
+        	to = event.isCancelled() ? event.getFrom() : event.getTo();
+        	x = to.getX();
+        	y = to.getY();
+        	z = to.getZ();
+        	yaw = to.getYaw();
+        	pitch = to.getPitch();
+        }
+        
+        this.internalTeleport(x, y, z, yaw, pitch, relativeSet);
+        //if (++this.teleportId == Integer.MAX_VALUE)
+        //{
+        //    this.teleportId = 0;
+        //}
 
-        if (++this.teleportId == Integer.MAX_VALUE)
-        {
+        //this.lastPositionUpdate = this.networkTickCount;
+        //this.playerEntity.setPositionAndRotation(this.targetPos.xCoord, this.targetPos.yCoord, this.targetPos.zCoord, f, f1);
+        //this.playerEntity.connection.sendPacket(new SPacketPlayerPosLook(x, y, z, yaw, pitch, relativeSet, this.teleportId));
+    }
+    public void teleport(Location dest) {
+    	internalTeleport(dest.getX(), dest.getY(), dest.getZ(), dest.getYaw(), dest.getPitch(), Collections.<SPacketPlayerPosLook.EnumFlags>emptySet());
+    }
+    private void internalTeleport(double x, double y, double z, float yaw, float pitch, Set<SPacketPlayerPosLook.EnumFlags> set) {
+    	if (Float.isNaN(yaw)) {
+    		yaw = 0.0f;
+        }
+        if (Float.isNaN(pitch)) {
+        	pitch = 0.0f;
+        }
+        this.justTeleported = true;
+        this.targetPos = new Vec3d(x, y, z);
+        if (set.contains(SPacketPlayerPosLook.EnumFlags.X)) {
+            this.targetPos = this.targetPos.addVector(this.playerEntity.posX, 0.0, 0.0);
+        }
+        if (set.contains(SPacketPlayerPosLook.EnumFlags.Y)) {
+            this.targetPos = this.targetPos.addVector(0.0, this.playerEntity.posY, 0.0);
+        }
+        if (set.contains(SPacketPlayerPosLook.EnumFlags.Z)) {
+            this.targetPos = this.targetPos.addVector(0.0, 0.0, this.playerEntity.posZ);
+        }
+        float f2 = yaw;
+        float f3 = pitch;
+        if (set.contains(SPacketPlayerPosLook.EnumFlags.Y_ROT)) {
+            f2 = yaw + this.playerEntity.rotationYaw;
+        }
+        if (set.contains(SPacketPlayerPosLook.EnumFlags.X_ROT)) {
+            f3 = pitch + this.playerEntity.rotationPitch;
+        }
+        this.lastPosX = this.targetPos.xCoord;
+        this.lastPosY = this.targetPos.yCoord;
+        this.lastPosZ = this.targetPos.zCoord;
+        this.lastYaw = f2;
+        this.lastPitch = f3;
+        if (++this.teleportId == Integer.MAX_VALUE) {
             this.teleportId = 0;
         }
-
         this.lastPositionUpdate = this.networkTickCount;
-        this.playerEntity.setPositionAndRotation(this.targetPos.xCoord, this.targetPos.yCoord, this.targetPos.zCoord, f, f1);
-        this.playerEntity.connection.sendPacket(new SPacketPlayerPosLook(x, y, z, yaw, pitch, relativeSet, this.teleportId));
+        this.playerEntity.setPositionAndRotation(this.targetPos.xCoord, this.targetPos.yCoord, this.targetPos.zCoord, f2, f3);
+        this.playerEntity.connection.sendPacket(new SPacketPlayerPosLook(x, y, z, yaw, pitch, set, this.teleportId));
     }
 
     public void processPlayerDigging(CPacketPlayerDigging packetIn)
     {
         PacketThreadUtil.checkThreadAndEnqueue(packetIn, this, this.playerEntity.getServerWorld());
+        if (this.playerEntity.isDead) return; // CraftBukkit
         WorldServer worldserver = this.serverController.worldServerForDimension(this.playerEntity.dimension);
         BlockPos blockpos = packetIn.getPosition();
         this.playerEntity.markPlayerActive();
-
         switch (packetIn.getAction())
         {
-            case SWAP_HELD_ITEMS:
-
+            case SWAP_HELD_ITEMS: //BC
+            	
                 if (!this.playerEntity.isSpectator())
                 {
-                    ItemStack itemstack1 = this.playerEntity.getHeldItem(EnumHand.OFF_HAND);
-                    this.playerEntity.setHeldItem(EnumHand.OFF_HAND, this.playerEntity.getHeldItem(EnumHand.MAIN_HAND));
-                    this.playerEntity.setHeldItem(EnumHand.MAIN_HAND, itemstack1);
+                //    ItemStack itemstack1 = this.playerEntity.getHeldItem(EnumHand.OFF_HAND);
+                //    this.playerEntity.setHeldItem(EnumHand.OFF_HAND, this.playerEntity.getHeldItem(EnumHand.MAIN_HAND));
+                //    this.playerEntity.setHeldItem(EnumHand.MAIN_HAND, itemstack1);
+                	final PlayerSwapHandItemsEvent swapItemsEvent = new PlayerSwapHandItemsEvent(this.getPlayer(), CraftItemStack.asBukkitCopy(this.playerEntity.getHeldItem(EnumHand.OFF_HAND)), CraftItemStack.asBukkitCopy(this.playerEntity.getHeldItem(EnumHand.MAIN_HAND)));
+                    this.server.getPluginManager().callEvent(swapItemsEvent);
+                    if (swapItemsEvent.isCancelled()) {
+                        return;
+                    }
+                    final ItemStack itemstack = CraftItemStack.asNMSCopy(swapItemsEvent.getMainHandItem());
+                    this.playerEntity.setHeldItem(EnumHand.OFF_HAND, CraftItemStack.asNMSCopy(swapItemsEvent.getOffHandItem()));
+                    this.playerEntity.setHeldItem(EnumHand.MAIN_HAND, itemstack);
                 }
 
                 return;
-            case DROP_ITEM:
+            case DROP_ITEM: // BC
 
                 if (!this.playerEntity.isSpectator())
                 {
+                    //this.playerEntity.dropItem(false);
+                	if (this.lastDropTick != MinecraftServer.currentTick) {
+                        this.dropCount = 0;
+                        this.lastDropTick = MinecraftServer.currentTick;
+                    }
+                    else {
+                        ++this.dropCount;
+                        if (this.dropCount >= 20) {
+                            NetHandlerPlayServer.LOGGER.warn(String.valueOf(this.playerEntity.getName()) + " dropped their items too quickly!");
+                            this.kickPlayerFromServer("You dropped your items too quickly (Hacking?)");
+                            return;
+                        }
+                    }
                     this.playerEntity.dropItem(false);
                 }
 
++++ END PATCH
++++ REJECTED PATCH 20
                         }
                         else
                         {
+                        	// CraftBukkit start - fire PlayerInteractEvent
+                        	CraftEventFactory.callPlayerInteractEvent(this.playerEntity, Action.LEFT_CLICK_BLOCK, blockpos, packetIn.getFacing(), this.playerEntity.inventory.getCurrentItem(), EnumHand.MAIN_HAND);
                             this.playerEntity.connection.sendPacket(new SPacketBlockChange(worldserver, blockpos));
+                            final TileEntity tileentity = worldserver.getTileEntity(blockpos);
+                            if (tileentity != null) {
+                                this.playerEntity.connection.sendPacket(tileentity.getUpdatePacket());
+                            }
                         }
                     }
                     else
++++ END PATCH
++++ REJECTED PATCH 21
     public void processRightClickBlock(CPacketPlayerTryUseItemOnBlock packetIn)
     {
         PacketThreadUtil.checkThreadAndEnqueue(packetIn, this, this.playerEntity.getServerWorld());
+        if (this.playerEntity.isDead) return; // CraftBukkit
         WorldServer worldserver = this.serverController.worldServerForDimension(this.playerEntity.dimension);
         EnumHand enumhand = packetIn.getHand();
         ItemStack itemstack = this.playerEntity.getHeldItem(enumhand);
++++ END PATCH
++++ REJECTED PATCH 22
 
         if (blockpos.getY() < this.serverController.getBuildLimit() - 1 || enumfacing != EnumFacing.UP && blockpos.getY() < this.serverController.getBuildLimit())
         {
-            double dist = playerEntity.interactionManager.getBlockReachDistance() + 3;
-            dist *= dist;
-            if (this.targetPos == null && this.playerEntity.getDistanceSq((double)blockpos.getX() + 0.5D, (double)blockpos.getY() + 0.5D, (double)blockpos.getZ() + 0.5D) < dist && !this.serverController.isBlockProtected(worldserver, blockpos, this.playerEntity) && worldserver.getWorldBorder().contains(blockpos))
-            {
-                this.playerEntity.interactionManager.processRightClickBlock(this.playerEntity, worldserver, itemstack, enumhand, blockpos, enumfacing, packetIn.getFacingX(), packetIn.getFacingY(), packetIn.getFacingZ());
+            //double dist = playerEntity.interactionManager.getBlockReachDistance() + 3;
+            //dist *= dist;
+            //if (this.targetPos == null && this.playerEntity.getDistanceSq((double)blockpos.getX() + 0.5D, (double)blockpos.getY() + 0.5D, (double)blockpos.getZ() + 0.5D) < dist && !this.serverController.isBlockProtected(worldserver, blockpos, this.playerEntity) && worldserver.getWorldBorder().contains(blockpos))
+            //{
+            //    this.playerEntity.interactionManager.processRightClickBlock(this.playerEntity, worldserver, itemstack, enumhand, blockpos, enumfacing, packetIn.getFacingX(), packetIn.getFacingY(), packetIn.getFacingZ());
+            //}
+        	final Location eyeLoc = this.getPlayer().getEyeLocation();
+            final double reachDistance = NumberConversions.square(eyeLoc.getX() - blockpos.getX()) + NumberConversions.square(eyeLoc.getY() - blockpos.getY()) + NumberConversions.square(eyeLoc.getZ() - blockpos.getZ());
+            if (reachDistance > ((this.getPlayer().getGameMode() == GameMode.CREATIVE) ? 49 : 36)) {
+                return;
             }
+            this.playerEntity.interactionManager.processRightClickBlock(this.playerEntity, worldserver, itemstack, enumhand, blockpos, enumfacing, packetIn.getFacingX(), packetIn.getFacingY(), packetIn.getFacingZ());
         }
         else
         {
++++ END PATCH
++++ REJECTED PATCH 23
     public void processPlayerBlockPlacement(CPacketPlayerTryUseItem packetIn)
     {
         PacketThreadUtil.checkThreadAndEnqueue(packetIn, this, this.playerEntity.getServerWorld());
+        if (this.playerEntity.isDead) return; // CraftBukkit
         WorldServer worldserver = this.serverController.worldServerForDimension(this.playerEntity.dimension);
         EnumHand enumhand = packetIn.getHand();
         ItemStack itemstack = this.playerEntity.getHeldItem(enumhand);
++++ END PATCH
++++ REJECTED PATCH 24
 
         if (itemstack != null)
         {
-            this.playerEntity.interactionManager.processRightClick(this.playerEntity, worldserver, itemstack, enumhand);
+            /*this.playerEntity.interactionManager.processRightClick(this.playerEntity, worldserver, itemstack, enumhand);
             itemstack = this.playerEntity.getHeldItem(enumhand);
 
             if (itemstack != null && itemstack.stackSize == 0)
++++ END PATCH
++++ REJECTED PATCH 25
                 this.playerEntity.setHeldItem(enumhand, (ItemStack)null);
                 net.minecraftforge.event.ForgeEventFactory.onPlayerDestroyItem(this.playerEntity, itemstack, enumhand);
                 itemstack = null;
+            }*/
+        	final float f1 = this.playerEntity.rotationPitch;
+            final float f2 = this.playerEntity.rotationYaw;
+            final double d0 = this.playerEntity.posX;
+            final double d2 = this.playerEntity.posY + this.playerEntity.getEyeHeight();
+            final double d3 = this.playerEntity.posZ;
+            final Vec3d vec3d = new Vec3d(d0, d2, d3);
+            final float f3 = MathHelper.cos(-f2 * 0.017453292f - 3.1415927f);
+            final float f4 = MathHelper.sin(-f2 * 0.017453292f - 3.1415927f);
+            final float f5 = -MathHelper.cos(-f1 * 0.017453292f);
+            final float f6 = MathHelper.sin(-f1 * 0.017453292f);
+            final float f7 = f4 * f5;
+            final float f8 = f3 * f5;
+            final double d4 = (this.playerEntity.interactionManager.getGameType() == GameType.CREATIVE) ? 5.0 : 4.5;
+            final Vec3d vec3d2 = vec3d.addVector(f7 * d4, f6 * d4, f8 * d4);
+            final RayTraceResult movingobjectposition = this.playerEntity.worldObj.rayTraceBlocks(vec3d, vec3d2, false);
+            boolean cancelled = false;
+            if (movingobjectposition == null || movingobjectposition.typeOfHit != RayTraceResult.Type.BLOCK) {
+                final PlayerInteractEvent event = CraftEventFactory.callPlayerInteractEvent(this.playerEntity, Action.RIGHT_CLICK_AIR, itemstack, enumhand);
+                cancelled = (event.useItemInHand() == Event.Result.DENY);
             }
+            else if (this.playerEntity.interactionManager.firedInteract) {
+                this.playerEntity.interactionManager.firedInteract = false;
+                cancelled = this.playerEntity.interactionManager.interactResult;
+            }
+            else {
+                final PlayerInteractEvent event = CraftEventFactory.callPlayerInteractEvent(this.playerEntity, Action.RIGHT_CLICK_BLOCK, movingobjectposition.getBlockPos(), movingobjectposition.sideHit, itemstack, true, enumhand);
+                cancelled = (event.useItemInHand() == Event.Result.DENY);
+            }
+            if (!cancelled) {
+                this.playerEntity.interactionManager.processRightClick(this.playerEntity, worldserver, itemstack, enumhand);
+                itemstack = this.playerEntity.getHeldItem(enumhand);
+                if (itemstack != null && itemstack.stackSize == 0) {
+                    this.playerEntity.setHeldItem(enumhand, null);
+                    itemstack = null;
+                }
+            }
         }
     }
 
++++ END PATCH
++++ REJECTED PATCH 27
 
     public void onDisconnect(ITextComponent reason)
     {
-        LOGGER.info("{} lost connection: {}", new Object[] {this.playerEntity.getName(), reason});
+    	// CraftBukkit start - Rarely it would send a disconnect line twice
+    	if (this.processedDisconnect) {
+            return;
+        }
+        this.processedDisconnect = true;
+        NetHandlerPlayServer.LOGGER.info("{} lost connection: {}", new Object[] { this.playerEntity.getName(), reason.getUnformattedText() });
+        /*LOGGER.info("{} lost connection: {}", new Object[] {this.playerEntity.getName(), reason});
         this.serverController.refreshStatusNextTick();
         TextComponentTranslation textcomponenttranslation = new TextComponentTranslation("multiplayer.player.left", new Object[] {this.playerEntity.getDisplayName()});
         textcomponenttranslation.getStyle().setColor(TextFormatting.YELLOW);
         this.serverController.getPlayerList().sendChatMsg(textcomponenttranslation);
+        */
         this.playerEntity.mountEntityAndWakeUp();
-        this.serverController.getPlayerList().playerLoggedOut(this.playerEntity);
-
+        //this.serverController.getPlayerList().playerLoggedOut(this.playerEntity);
+        final String quitMessage = this.serverController.getPlayerList().playerLoggedOut(this.playerEntity);
+        if (quitMessage != null && quitMessage.length() > 0) {
+            this.serverController.getPlayerList().sendMessage(CraftChatMessage.fromString(quitMessage));
+        }
+        // CB end
         if (this.serverController.isSinglePlayer() && this.playerEntity.getName().equals(this.serverController.getServerOwner()))
         {
             LOGGER.info("Stopping singleplayer server as player logged out");
++++ END PATCH
++++ REJECTED PATCH 28
     public void processHeldItemChange(CPacketHeldItemChange packetIn)
     {
         PacketThreadUtil.checkThreadAndEnqueue(packetIn, this, this.playerEntity.getServerWorld());
-
+        if (this.playerEntity.isDead) return; // CraftBukkit
         if (packetIn.getSlotId() >= 0 && packetIn.getSlotId() < InventoryPlayer.getHotbarSize())
         {
+        	PlayerItemHeldEvent event = new PlayerItemHeldEvent(this.getPlayer(), this.playerEntity.inventory.currentItem, packetIn.getSlotId());
+        	this.server.getPluginManager().callEvent(event);
+        	if (event.isCancelled()) {
+        		this.sendPacket(new SPacketHeldItemChange(this.playerEntity.inventory.currentItem));
+        		this.playerEntity.markPlayerActive();
+        		return;
+        	}
+        	// CraftBukkit end
             this.playerEntity.inventory.currentItem = packetIn.getSlotId();
             this.playerEntity.markPlayerActive();
         }
         else
         {
             LOGGER.warn("{} tried to set an invalid carried item", new Object[] {this.playerEntity.getName()});
+            this.kickPlayerFromServer("Nope!"); // CraftBukkit
         }
     }
 
     public void processChatMessage(CPacketChatMessage packetIn)
     {
-        PacketThreadUtil.checkThreadAndEnqueue(packetIn, this, this.playerEntity.getServerWorld());
+        //PacketThreadUtil.checkThreadAndEnqueue(packetIn, this, this.playerEntity.getServerWorld());
+    	// CraftBukkit start - async chat
+    	boolean isSync = packetIn.getMessage().startsWith("/");
+    	if (isSync) {
+    		PacketThreadUtil.checkThreadAndEnqueue(packetIn, this, this.playerEntity.getServerWorld());
+    	}
 
-        if (this.playerEntity.getChatVisibility() == EntityPlayer.EnumChatVisibility.HIDDEN)
+        if (this.playerEntity.isDead || this.playerEntity.getChatVisibility() == EntityPlayer.EnumChatVisibility.HIDDEN)
         {
             TextComponentTranslation textcomponenttranslation = new TextComponentTranslation("chat.cannotSend", new Object[0]);
             textcomponenttranslation.getStyle().setColor(TextFormatting.RED);
++++ END PATCH
++++ REJECTED PATCH 29
             {
                 if (!ChatAllowedCharacters.isAllowedCharacter(s.charAt(i)))
                 {
-                    this.kickPlayerFromServer("Illegal characters in chat");
+                    //this.kickPlayerFromServer("Illegal characters in chat");
+                	// CraftBukkit start - threadsafety
+                	if (!isSync) {
+                		Waitable<Object> waitable = new Waitable<Object>() {
+                			@Override
+                			protected Object evaluate() {
+                				kickPlayerFromServer("Illegal characters in chat");
+                				return null;
+                			}
+                		};
+                	
+                		this.serverController.processQueue.add(waitable);
+                		
+                		try {
+                			waitable.get(); // Will wait
+                		} catch (InterruptedException e) {
+                			Thread.currentThread().interrupt();
+                		} catch (ExecutionException e) {
+                			throw new RuntimeException(e);
+                		}
+                	} else {
+                		kickPlayerFromServer("Illegal characters in chat");
+                	}
+                	// CraftBukkit end
                     return;
                 }
             }
 
-            if (s.startsWith("/"))
+            if (isSync/*s.startsWith("/")*/)
             {
-                this.handleSlashCommand(s);
+                //this.handleSlashCommand(s);
+            	try {
+                    this.serverController.server.playerCommandState = true;
+                    this.handleSlashCommand(s);
+                }
+                finally {
+                    this.serverController.server.playerCommandState = false;
+                }
+                this.serverController.server.playerCommandState = false;
             }
-            else
-            {
-                ITextComponent itextcomponent = new TextComponentTranslation("chat.type.text", this.playerEntity.getDisplayName(), net.minecraftforge.common.ForgeHooks.newChatWithLinks(s));
-                itextcomponent = net.minecraftforge.common.ForgeHooks.onServerChatEvent(this, s, itextcomponent);
-                if (itextcomponent == null) return;
-                this.serverController.getPlayerList().sendChatMsgImpl(itextcomponent, false);
+            else if (s.isEmpty()) {
+                NetHandlerPlayServer.LOGGER.warn(String.valueOf(this.playerEntity.getName()) + " tried to send an empty message");
             }
+            else if (this.getPlayer().isConversing()) {
+                this.getPlayer().acceptConversationInput(s);
+            }
+            else if (this.playerEntity.getChatVisibility() == EntityPlayer.EnumChatVisibility.SYSTEM) {
+                final TextComponentTranslation chatmessage2 = new TextComponentTranslation("chat.cannotSend", new Object[0]);
+                chatmessage2.getStyle().setColor(TextFormatting.RED);
+                this.sendPacket(new SPacketChat(chatmessage2));
+            }
+            else if (true){
+                this.chat(s, true);
+            }
+            //else
+            //{ // Dead code.
+            //    ITextComponent itextcomponent = new TextComponentTranslation("chat.type.text", this.playerEntity.getDisplayName(), net.minecraftforge.common.ForgeHooks.newChatWithLinks(s));
+            //    itextcomponent = net.minecraftforge.common.ForgeHooks.onServerChatEvent(this, s, itextcomponent);
+            //    if (itextcomponent == null) return;
+            //    this.serverController.getPlayerList().sendChatMsgImpl(itextcomponent, false);
+            //}
 
-            this.chatSpamThresholdCount += 20;
+            /*this.chatSpamThresholdCount += 20;
 
             if (this.chatSpamThresholdCount > 200 && !this.serverController.getPlayerList().canSendCommands(this.playerEntity.getGameProfile()))
             {
                 this.kickPlayerFromServer("disconnect.spam");
+            }*/
+            if (NetHandlerPlayServer.chatSpamField.addAndGet(this, 20) > 200 && !this.serverController.getPlayerList().canSendCommands(this.playerEntity.getGameProfile())) {
+                if (!isSync) {
+                    final Waitable<Object> waitable2 = new Waitable<Object>() {
+                        @Override
+                        protected Object evaluate() {
+                            NetHandlerPlayServer.this.kickPlayerFromServer("disconnect.spam");
+                            return null;
+                        }
+                    };
+                    this.serverController.processQueue.add(waitable2);
+                    try {
+                        waitable2.get();
+                        return;
+                    }
+                    catch (InterruptedException ex2) {
+                        Thread.currentThread().interrupt();
+                        return;
+                    }
+                    catch (ExecutionException e2) {
+                        throw new RuntimeException(e2);
+                    }
+                }
+                this.kickPlayerFromServer("disconnect.spam");
             }
         }
     }
-
+    // CraftBukkit start - add method
+    public void chat(String s, final boolean async) {
+        if (s.isEmpty() || this.playerEntity.getChatVisibility() == EntityPlayer.EnumChatVisibility.HIDDEN) {
+            return;
+        }
+        if (!async && s.startsWith("/")) {
+            this.handleSlashCommand(s);
+        }
+        else if (this.playerEntity.getChatVisibility() != EntityPlayer.EnumChatVisibility.SYSTEM) {
+            final Player player = this.getPlayer();
+            final AsyncPlayerChatEvent event = new AsyncPlayerChatEvent(async, player, s, new LazyPlayerSet(this.serverController));
+            this.server.getPluginManager().callEvent(event);
+            if (PlayerChatEvent.getHandlerList().getRegisteredListeners().length != 0) {
+                final PlayerChatEvent queueEvent = new PlayerChatEvent(player, event.getMessage(), event.getFormat(), event.getRecipients());
+                queueEvent.setCancelled(event.isCancelled());
+                final Waitable waitable = new Waitable() {
+                    @Override
+                    protected Object evaluate() {
+                        Bukkit.getPluginManager().callEvent(queueEvent);
+                        if (queueEvent.isCancelled()) {
+                            return null;
+                        }
+                        final String message = String.format(queueEvent.getFormat(), queueEvent.getPlayer().getDisplayName(), queueEvent.getMessage());
+                        NetHandlerPlayServer.this.serverController.console.sendMessage(message);
+                        if (((LazyPlayerSet)queueEvent.getRecipients()).isLazy()) {
+                            for (final Object player : NetHandlerPlayServer.this.serverController.getPlayerList().playerEntityList) {
+                                ((EntityPlayerMP)player).sendMessage(CraftChatMessage.fromString(message));
+                            }
+                        }
+                        else {
+                            for (final Player player2 : queueEvent.getRecipients()) {
+                                player2.sendMessage(message);
+                            }
+                        }
+                        return null;
+                    }
+                };
+                if (async) {
+                    this.serverController.processQueue.add(waitable);
+                }
+                else {
+                    waitable.run();
+                }
+                try {
+                    waitable.get();
+                    return;
+                }
+                catch (InterruptedException ex) {
+                    Thread.currentThread().interrupt();
+                    return;
+                }
+                catch (ExecutionException e) {
+                    throw new RuntimeException("Exception processing chat event", e.getCause());
+                }
+            }
+            if (event.isCancelled()) {
+                return;
+            }
+            s = String.format(event.getFormat(), event.getPlayer().getDisplayName(), event.getMessage());
+            this.serverController.console.sendMessage(s);
+            if (((LazyPlayerSet)event.getRecipients()).isLazy()) {
+                for (final Object recipient : this.serverController.getPlayerList().playerEntityList) {
+                    ((EntityPlayerMP)recipient).sendMessage(CraftChatMessage.fromString(s));
+                }
+            }
+            else {
+                for (final Player recipient2 : event.getRecipients()) {
+                    recipient2.sendMessage(s);
+                }
+            }
+        }
+    }
+    // CraftBukkit end
     private void handleSlashCommand(String command)
     {
-        this.serverController.getCommandManager().executeCommand(this.playerEntity, command);
+        //this.serverController.getCommandManager().executeCommand(this.playerEntity, command);
+    	NetHandlerPlayServer.LOGGER.info(String.valueOf(this.playerEntity.getName()) + " issued server command: " + command);
+        final CraftPlayer player = this.getPlayer();
+        final PlayerCommandPreprocessEvent event = new PlayerCommandPreprocessEvent(player, command, new LazyPlayerSet(this.serverController));
+        this.server.getPluginManager().callEvent(event);
+        if (event.isCancelled()) {
+            return;
+        }
+        try {
+            if (this.server.dispatchCommand(event.getPlayer(), event.getMessage().substring(1))) {
+                return;
+            }
+        }
+        catch (CommandException ex) {
+            player.sendMessage(ChatColor.RED + "An internal error occurred while attempting to perform this command");
+            java.util.logging.Logger.getLogger(NetHandlerPlayServer.class.getName()).log(Level.SEVERE, null, ex);
+        }
     }
 
     public void handleAnimation(CPacketAnimation packetIn)
     {
         PacketThreadUtil.checkThreadAndEnqueue(packetIn, this, this.playerEntity.getServerWorld());
+        if(this.playerEntity.isDead) return; // CraftBukkit
         this.playerEntity.markPlayerActive();
+        // CB start
+        final float f1 = this.playerEntity.rotationPitch;
+        final float f2 = this.playerEntity.rotationYaw;
+        final double d0 = this.playerEntity.posX;
+        final double d2 = this.playerEntity.posY + this.playerEntity.getEyeHeight();
+        final double d3 = this.playerEntity.posZ;
+        final Vec3d vec3d = new Vec3d(d0, d2, d3);
+        final float f3 = MathHelper.cos(-f2 * 0.017453292f - 3.1415927f);
+        final float f4 = MathHelper.sin(-f2 * 0.017453292f - 3.1415927f);
+        final float f5 = -MathHelper.cos(-f1 * 0.017453292f);
+        final float f6 = MathHelper.sin(-f1 * 0.017453292f);
+        final float f7 = f4 * f5;
+        final float f8 = f3 * f5;
+        final double d4 = (this.playerEntity.interactionManager.getGameType() == GameType.CREATIVE) ? 5.0 : 4.5;
+        final Vec3d vec3d2 = vec3d.addVector(f7 * d4, f6 * d4, f8 * d4);
+        final RayTraceResult movingobjectposition = this.playerEntity.worldObj.rayTraceBlocks(vec3d, vec3d2, false);
+        if (movingobjectposition == null || movingobjectposition.typeOfHit != RayTraceResult.Type.BLOCK) {
+            CraftEventFactory.callPlayerInteractEvent(this.playerEntity, Action.LEFT_CLICK_AIR, this.playerEntity.inventory.getCurrentItem(), EnumHand.MAIN_HAND);
+        }
+        final PlayerAnimationEvent event = new PlayerAnimationEvent(this.getPlayer());
+        this.server.getPluginManager().callEvent(event);
+        if (event.isCancelled()) {
+            return;
+        }
+        // CB end
         this.playerEntity.swingArm(packetIn.getHand());
     }
 
     public void processEntityAction(CPacketEntityAction packetIn)
     {
         PacketThreadUtil.checkThreadAndEnqueue(packetIn, this, this.playerEntity.getServerWorld());
+        // CB start
+        if (this.playerEntity.isDead) {
+            return;
+        }
+        switch (packetIn.getAction()) {
+            case START_SNEAKING:
+            case STOP_SNEAKING: {
+                final PlayerToggleSneakEvent event = new PlayerToggleSneakEvent(this.getPlayer(), packetIn.getAction() == CPacketEntityAction.Action.START_SNEAKING);
+                this.server.getPluginManager().callEvent(event);
+                if (event.isCancelled()) {
+                    return;
+                }
+                break;
+            }
+            case START_SPRINTING:
+            case STOP_SPRINTING: {
+                final PlayerToggleSprintEvent e2 = new PlayerToggleSprintEvent(this.getPlayer(), packetIn.getAction() == CPacketEntityAction.Action.START_SPRINTING);
+                this.server.getPluginManager().callEvent(e2);
+                if (e2.isCancelled()) {
+                    return;
+                }
+                break;
+            }
+        }
+        // CB end
         this.playerEntity.markPlayerActive();
 
         switch (packetIn.getAction())
++++ END PATCH
++++ REJECTED PATCH 30
     public void processUseEntity(CPacketUseEntity packetIn)
     {
         PacketThreadUtil.checkThreadAndEnqueue(packetIn, this, this.playerEntity.getServerWorld());
+        if (this.playerEntity.isDead) return; // CraftBukkit
         WorldServer worldserver = this.serverController.worldServerForDimension(this.playerEntity.dimension);
         Entity entity = packetIn.getEntityFromWorld(worldserver);
         this.playerEntity.markPlayerActive();
++++ END PATCH
++++ REJECTED PATCH 31
             {
                 d0 = 9.0D;
             }
-
+            // CB start
+            final ItemStack itemInHand = this.playerEntity.getHeldItem((packetIn.getHand() == null) ? EnumHand.MAIN_HAND : packetIn.getHand());
+            if (packetIn.getAction() == CPacketUseEntity.Action.INTERACT || packetIn.getAction() == CPacketUseEntity.Action.INTERACT_AT) {
+                final boolean triggerLeashUpdate = itemInHand != null && itemInHand.getItem() == Items.LEAD && entity instanceof EntityLiving;
+                final Item origItem = (this.playerEntity.inventory.getCurrentItem() == null) ? null : this.playerEntity.inventory.getCurrentItem().getItem();
+                PlayerInteractEntityEvent event;
+                if (packetIn.getAction() == CPacketUseEntity.Action.INTERACT) {
+                    event = new PlayerInteractEntityEvent(this.getPlayer(), entity.getBukkitEntity(), (packetIn.getHand() == EnumHand.OFF_HAND) ? EquipmentSlot.OFF_HAND : EquipmentSlot.HAND);
+                }
+                else {
+                    final Vec3d target = packetIn.getHitVec();
+                    event = new PlayerInteractAtEntityEvent(this.getPlayer(), entity.getBukkitEntity(), new Vector(target.xCoord, target.yCoord, target.zCoord), (packetIn.getHand() == EnumHand.OFF_HAND) ? EquipmentSlot.OFF_HAND : EquipmentSlot.HAND);
+                }
+                this.server.getPluginManager().callEvent(event);
+                if (triggerLeashUpdate && (event.isCancelled() || this.playerEntity.inventory.getCurrentItem() == null || this.playerEntity.inventory.getCurrentItem().getItem() != Items.LEAD)) {
+                    this.sendPacket(new SPacketEntityAttach(entity, ((EntityLiving)entity).getLeashedToEntity()));
+                }
+                if (event.isCancelled() || this.playerEntity.inventory.getCurrentItem() == null || this.playerEntity.inventory.getCurrentItem().getItem() != origItem) {
+                    this.sendPacket(new SPacketEntityMetadata(entity.getEntityId(), entity.dataManager, true));
+                }
+                if (event.isCancelled()) {
+                    return;
+                }
+            }
+            // CB end
             if (this.playerEntity.getDistanceSqToEntity(entity) < d0)
             {
                 if (packetIn.getAction() == CPacketUseEntity.Action.INTERACT)
++++ END PATCH
++++ REJECTED PATCH 32
                     EnumHand enumhand = packetIn.getHand();
                     ItemStack itemstack = this.playerEntity.getHeldItem(enumhand);
                     this.playerEntity.interact(entity, itemstack, enumhand);
+                    // CraftBukkit start
+                    if (itemInHand != null && itemInHand.stackSize <= -1) {
+                    	this.playerEntity.sendContainerToPlayer(this.playerEntity.openContainer);
+                    }
+                    // CraftBukkit end
                 }
                 else if (packetIn.getAction() == CPacketUseEntity.Action.INTERACT_AT)
                 {
++++ END PATCH
++++ REJECTED PATCH 33
                     ItemStack itemstack1 = this.playerEntity.getHeldItem(enumhand1);
                     if(net.minecraftforge.common.ForgeHooks.onInteractEntityAt(playerEntity, entity, packetIn.getHitVec(), itemstack1, enumhand1)) return;
                     entity.applyPlayerInteraction(this.playerEntity, packetIn.getHitVec(), itemstack1, enumhand1);
+                    // CraftBukkit start
+                    if (itemInHand != null && itemInHand.stackSize <= -1) {
+                    	this.playerEntity.sendContainerToPlayer(this.playerEntity.openContainer);
+                    }
+                    // CraftBukkit end
                 }
                 else if (packetIn.getAction() == CPacketUseEntity.Action.ATTACK)
                 {
-                    if (entity instanceof EntityItem || entity instanceof EntityXPOrb || entity instanceof EntityArrow || entity == this.playerEntity)
+                    if (entity instanceof EntityItem || entity instanceof EntityXPOrb || entity instanceof EntityArrow || (entity == this.playerEntity && !this.playerEntity.isSpectator())) // CB
                     {
                         this.kickPlayerFromServer("Attempting to attack an invalid entity");
                         this.serverController.logWarning("Player " + this.playerEntity.getName() + " tried to attack an invalid entity");
++++ END PATCH
++++ REJECTED PATCH 34
                     }
 
                     this.playerEntity.attackTargetEntityWithCurrentItem(entity);
+                    // CraftBukkit start
+                    if (itemInHand != null && itemInHand.stackSize <= -1) {
+                    	this.playerEntity.sendContainerToPlayer(this.playerEntity.openContainer);
+                    }
+                    // CraftBukkit end
                 }
             }
         }
++++ END PATCH
++++ REJECTED PATCH 35
                 if (this.playerEntity.playerConqueredTheEnd)
                 {
                     this.playerEntity.playerConqueredTheEnd = false;
-                    this.playerEntity = this.serverController.getPlayerList().recreatePlayerEntity(this.playerEntity, 0, true);
+                    //this.playerEntity = this.serverController.getPlayerList().recreatePlayerEntity(this.playerEntity, 0, true);
+                    this.serverController.getPlayerList().changeDimension(this.playerEntity, 0, PlayerTeleportEvent.TeleportCause.END_PORTAL); // CraftBukkit - reroute logic through custom portal management
                 }
                 else
                 {
++++ END PATCH
++++ REJECTED PATCH 36
     public void processCloseWindow(CPacketCloseWindow packetIn)
     {
         PacketThreadUtil.checkThreadAndEnqueue(packetIn, this, this.playerEntity.getServerWorld());
+        if (this.playerEntity.isDead) return; // CraftBukkit
+        CraftEventFactory.handleInventoryCloseEvent(this.playerEntity); // CraftBukkit
         this.playerEntity.closeContainer();
     }
 
     public void processClickWindow(CPacketClickWindow packetIn)
     {
         PacketThreadUtil.checkThreadAndEnqueue(packetIn, this, this.playerEntity.getServerWorld());
+        if (this.playerEntity.isDead) return; // CraftBukkit
         this.playerEntity.markPlayerActive();
 
         if (this.playerEntity.openContainer.windowId == packetIn.getWindowId() && this.playerEntity.openContainer.getCanCraft(this.playerEntity))
         {
-            if (this.playerEntity.isSpectator())
+        	boolean cancelled = this.playerEntity.isSpectator(); // CraftBukkit - see below if
+        	boolean cbInv = this.playerEntity.openContainer instanceof CBContainer;
+        	if(cancelled && !cbInv)
             {
                 List<ItemStack> list = Lists.<ItemStack>newArrayList();
 
++++ END PATCH
++++ REJECTED PATCH 37
 
                 this.playerEntity.updateCraftingInventory(this.playerEntity.openContainer, list);
             }
-            else
+        	else
             {
-                ItemStack itemstack2 = this.playerEntity.openContainer.slotClick(packetIn.getSlotId(), packetIn.getUsedButton(), packetIn.getClickType(), this.playerEntity);
+        		ItemStack itemstack = null;
+        		if(!cbInv) {
+        			itemstack = this.playerEntity.openContainer.slotClick(packetIn.getSlotId(), packetIn.getUsedButton(), packetIn.getClickType(), this.playerEntity);
+        		}
+            	if (packetIn.getSlotId() < -1 && packetIn.getSlotId() != -999) {
+                    return;
+                }
+            	if(cbInv) {
+                final InventoryView inventory = ((CBContainer)this.playerEntity.openContainer).getBukkitView();
+                final InventoryType.SlotType type = CraftInventoryView.getSlotType(inventory, packetIn.getSlotId());
+                ClickType click = ClickType.UNKNOWN;
+                InventoryAction action = InventoryAction.UNKNOWN;
+                switch (packetIn.getClickType()) {
+                    case PICKUP: {
+                        if (packetIn.getUsedButton() == 0) {
+                            click = ClickType.LEFT;
+                        }
+                        else if (packetIn.getUsedButton() == 1) {
+                            click = ClickType.RIGHT;
+                        }
+                        if (packetIn.getUsedButton() != 0 && packetIn.getUsedButton() != 1) {
+                            break;
+                        }
+                        action = InventoryAction.NOTHING;
+                        if (packetIn.getSlotId() == -999) {
+                            if (this.playerEntity.inventory.getItemStack() != null) {
+                                action = ((packetIn.getUsedButton() == 0) ? InventoryAction.DROP_ALL_CURSOR : InventoryAction.DROP_ONE_CURSOR);
+                                break;
+                            }
+                            break;
+                        }
+                        else {
+                            if (packetIn.getSlotId() < 0) {
+                                action = InventoryAction.NOTHING;
+                                break;
+                            }
+                            final Slot slot = this.playerEntity.openContainer.getSlot(packetIn.getSlotId());
+                            if (slot == null) {
+                                break;
+                            }
+                            final ItemStack clickedItem = slot.getStack();
+                            final ItemStack cursor = this.playerEntity.inventory.getItemStack();
+                            if (clickedItem == null) {
+                                if (cursor != null) {
+                                    action = ((packetIn.getUsedButton() == 0) ? InventoryAction.PLACE_ALL : InventoryAction.PLACE_ONE);
+                                    break;
+                                }
+                                break;
+                            }
+                            else {
+                                if (!slot.canTakeStack(this.playerEntity)) {
+                                    break;
+                                }
+                                if (cursor == null) {
+                                    action = ((packetIn.getUsedButton() == 0) ? InventoryAction.PICKUP_ALL : InventoryAction.PICKUP_HALF);
+                                    break;
+                                }
+                                if (slot.isItemValid(cursor)) {
+                                    if (clickedItem.isItemEqual(cursor) && ItemStack.areItemStackTagsEqual(clickedItem, cursor)) {
+                                        int toPlace = (packetIn.getUsedButton() == 0) ? cursor.stackSize : 1;
+                                        toPlace = Math.min(toPlace, clickedItem.getMaxStackSize() - clickedItem.stackSize);
+                                        toPlace = Math.min(toPlace, slot.inventory.getInventoryStackLimit() - clickedItem.stackSize);
+                                        if (toPlace == 1) {
+                                            action = InventoryAction.PLACE_ONE;
+                                            break;
+                                        }
+                                        if (toPlace == cursor.stackSize) {
+                                            action = InventoryAction.PLACE_ALL;
+                                            break;
+                                        }
+                                        if (toPlace < 0) {
+                                            action = ((toPlace != -1) ? InventoryAction.PICKUP_SOME : InventoryAction.PICKUP_ONE);
+                                            break;
+                                        }
+                                        if (toPlace != 0) {
+                                            action = InventoryAction.PLACE_SOME;
+                                            break;
+                                        }
+                                        break;
+                                    }
+                                    else {
+                                        if (cursor.stackSize <= slot.getSlotStackLimit()) {
+                                            action = InventoryAction.SWAP_WITH_CURSOR;
+                                            break;
+                                        }
+                                        break;
+                                    }
+                                }
+                                else {
+                                    if (cursor.getItem() == clickedItem.getItem() && (!cursor.getHasSubtypes() || cursor.getMetadata() == clickedItem.getMetadata()) && ItemStack.areItemStackTagsEqual(cursor, clickedItem) && clickedItem.stackSize >= 0 && clickedItem.stackSize + cursor.stackSize <= cursor.getMaxStackSize()) {
+                                        action = InventoryAction.PICKUP_ALL;
+                                        break;
+                                    }
+                                    break;
+                                }
+                            }
+                        }
+                        //break;
+                    }
+                    case QUICK_MOVE: {
+                        if (packetIn.getUsedButton() == 0) {
+                            click = ClickType.SHIFT_LEFT;
+                        }
+                        else if (packetIn.getUsedButton() == 1) {
+                            click = ClickType.SHIFT_RIGHT;
+                        }
+                        if (packetIn.getUsedButton() != 0 && packetIn.getUsedButton() != 1) {
+                            break;
+                        }
+                        if (packetIn.getSlotId() < 0) {
+                            action = InventoryAction.NOTHING;
+                            break;
+                        }
+                        final Slot slot = this.playerEntity.openContainer.getSlot(packetIn.getSlotId());
+                        if (slot != null && slot.canTakeStack(this.playerEntity) && slot.getHasStack()) {
+                            action = InventoryAction.MOVE_TO_OTHER_INVENTORY;
+                            break;
+                        }
+                        action = InventoryAction.NOTHING;
+                        break;
+                    }
+                    case SWAP: {
+                        if (packetIn.getUsedButton() < 0 || packetIn.getUsedButton() >= 9) {
+                            break;
+                        }
+                        click = ClickType.NUMBER_KEY;
+                        final Slot clickedSlot = this.playerEntity.openContainer.getSlot(packetIn.getSlotId());
+                        if (!clickedSlot.canTakeStack(this.playerEntity)) {
+                            action = InventoryAction.NOTHING;
+                            break;
+                        }
+                        final ItemStack hotbar = this.playerEntity.inventory.getStackInSlot(packetIn.getUsedButton());
+                        final boolean canCleanSwap = hotbar == null || (clickedSlot.inventory == this.playerEntity.inventory && clickedSlot.isItemValid(hotbar));
+                        if (clickedSlot.getHasStack()) {
+                            if (canCleanSwap) {
+                                action = InventoryAction.HOTBAR_SWAP;
+                                break;
+                            }
+                            final int firstEmptySlot = this.playerEntity.inventory.getFirstEmptyStack();
+                            if (firstEmptySlot > -1) {
+                                action = InventoryAction.HOTBAR_MOVE_AND_READD;
+                                break;
+                            }
+                            action = InventoryAction.NOTHING;
+                            break;
+                        }
+                        else {
+                            if (!clickedSlot.getHasStack() && hotbar != null && clickedSlot.isItemValid(hotbar)) {
+                                action = InventoryAction.HOTBAR_SWAP;
+                                break;
+                            }
+                            action = InventoryAction.NOTHING;
+                            break;
+                        }
+                        //break;
+                    }
+                    case CLONE: {
+                        if (packetIn.getUsedButton() != 2) {
+                            click = ClickType.UNKNOWN;
+                            action = InventoryAction.UNKNOWN;
+                            break;
+                        }
+                        click = ClickType.MIDDLE;
+                        if (packetIn.getSlotId() == -999) {
+                            action = InventoryAction.NOTHING;
+                            break;
+                        }
+                        final Slot slot = this.playerEntity.openContainer.getSlot(packetIn.getSlotId());
+                        if (slot != null && slot.getHasStack() && this.playerEntity.capabilities.isCreativeMode && this.playerEntity.inventory.getItemStack() == null) {
+                            action = InventoryAction.CLONE_STACK;
+                            break;
+                        }
+                        action = InventoryAction.NOTHING;
+                        break;
+                    }
+                    case THROW: {
+                        if (packetIn.getSlotId() < 0) {
+                            click = ClickType.LEFT;
+                            if (packetIn.getUsedButton() == 1) {
+                                click = ClickType.RIGHT;
+                            }
+                            action = InventoryAction.NOTHING;
+                            break;
+                        }
+                        if (packetIn.getUsedButton() == 0) {
+                            click = ClickType.DROP;
+                            final Slot slot = this.playerEntity.openContainer.getSlot(packetIn.getSlotId());
+                            if (slot != null && slot.getHasStack() && slot.canTakeStack(this.playerEntity) && slot.getStack() != null && slot.getStack().getItem() != Item.getItemFromBlock(Blocks.AIR)) {
+                                action = InventoryAction.DROP_ONE_SLOT;
+                                break;
+                            }
+                            action = InventoryAction.NOTHING;
+                            break;
+                        }
+                        else {
+                            if (packetIn.getUsedButton() != 1) {
+                                break;
+                            }
+                            click = ClickType.CONTROL_DROP;
+                            final Slot slot = this.playerEntity.openContainer.getSlot(packetIn.getSlotId());
+                            if (slot != null && slot.getHasStack() && slot.canTakeStack(this.playerEntity) && slot.getStack() != null && slot.getStack().getItem() != Item.getItemFromBlock(Blocks.AIR)) {
+                                action = InventoryAction.DROP_ALL_SLOT;
+                                break;
+                            }
+                            action = InventoryAction.NOTHING;
+                            break;
+                        }
+                        //break;
+                    }
+                    case QUICK_CRAFT: {
+                        itemstack = this.playerEntity.openContainer.slotClick(packetIn.getSlotId(), packetIn.getUsedButton(), packetIn.getClickType(), this.playerEntity);
+                        break;
+                    }
+                    case PICKUP_ALL: {
+                        click = ClickType.DOUBLE_CLICK;
+                        action = InventoryAction.NOTHING;
+                        if (packetIn.getSlotId() < 0 || this.playerEntity.inventory.getItemStack() == null) {
+                            break;
+                        }
+                        final ItemStack cursor2 = this.playerEntity.inventory.getItemStack();
+                        action = InventoryAction.NOTHING;
+                        if (inventory.getTopInventory().contains(org.bukkit.Material.getMaterial(Item.getIdFromItem(cursor2.getItem()))) || inventory.getBottomInventory().contains(org.bukkit.Material.getMaterial(Item.getIdFromItem(cursor2.getItem())))) {
+                            action = InventoryAction.COLLECT_TO_CURSOR;
+                            break;
+                        }
+                        break;
+                    }
+                }
+                if (packetIn.getClickType() != net.minecraft.inventory.ClickType.QUICK_CRAFT) {
+                    InventoryClickEvent event;
+                    if (click == ClickType.NUMBER_KEY) {
+                        event = new InventoryClickEvent(inventory, type, packetIn.getSlotId(), click, action, packetIn.getUsedButton());
+                    }
+                    else {
+                        event = new InventoryClickEvent(inventory, type, packetIn.getSlotId(), click, action);
+                    }
+                    final Inventory top = inventory.getTopInventory();
+                    if (packetIn.getSlotId() == 0 && top instanceof CraftingInventory) {
+                        final Recipe recipe = ((CraftingInventory)top).getRecipe();
+                        if (recipe != null) {
+                            if (click == ClickType.NUMBER_KEY) {
+                                event = new CraftItemEvent(recipe, inventory, type, packetIn.getSlotId(), click, action, packetIn.getUsedButton());
+                            }
+                            else {
+                                event = new CraftItemEvent(recipe, inventory, type, packetIn.getSlotId(), click, action);
+                            }
+                        }
+                    }
+                    event.setCancelled(cancelled);
+                    final Container oldContainer = this.playerEntity.openContainer;
+                    this.server.getPluginManager().callEvent(event);
+                    if (this.playerEntity.openContainer != oldContainer) {
+                        return;
+                    }
+                    switch (event.getResult()) {
+                        case DEFAULT:
+                        case ALLOW: {
+                            itemstack = this.playerEntity.openContainer.slotClick(packetIn.getSlotId(), packetIn.getUsedButton(), packetIn.getClickType(), this.playerEntity);
+                            break;
+                        }
+                        case DENY: {
+                            switch (action) {
+                                case PICKUP_ALL:
+                                case MOVE_TO_OTHER_INVENTORY:
+                                case HOTBAR_MOVE_AND_READD:
+                                case HOTBAR_SWAP:
+                                case COLLECT_TO_CURSOR:
+                                case UNKNOWN: {
+                                    this.playerEntity.sendContainerToPlayer(this.playerEntity.openContainer);
+                                    break;
+                                }
+                                case PICKUP_SOME:
+                                case PICKUP_HALF:
+                                case PICKUP_ONE:
+                                case PLACE_ALL:
+                                case PLACE_SOME:
+                                case PLACE_ONE:
+                                case SWAP_WITH_CURSOR: {
+                                    this.playerEntity.connection.sendPacket(new SPacketSetSlot(-1, -1, this.playerEntity.inventory.getItemStack()));
+                                    this.playerEntity.connection.sendPacket(new SPacketSetSlot(this.playerEntity.openContainer.windowId, packetIn.getSlotId(), this.playerEntity.openContainer.getSlot(packetIn.getSlotId()).getStack()));
+                                    break;
+                                }
+                                case DROP_ALL_SLOT:
+                                case DROP_ONE_SLOT: {
+                                    this.playerEntity.connection.sendPacket(new SPacketSetSlot(this.playerEntity.openContainer.windowId, packetIn.getSlotId(), this.playerEntity.openContainer.getSlot(packetIn.getSlotId()).getStack()));
+                                    break;
+                                }
+                                case DROP_ALL_CURSOR:
+                                case DROP_ONE_CURSOR:
+                                case CLONE_STACK: {
+                                    this.playerEntity.connection.sendPacket(new SPacketSetSlot(-1, -1, this.playerEntity.inventory.getItemStack()));
+                                    break;
+                                }
+                            }
+                            return;
+                        }
+                    }
+                    if (event instanceof CraftItemEvent) {
+                        this.playerEntity.sendContainerToPlayer(this.playerEntity.openContainer);
+                    }
+                }
+            	}
+                if (ItemStack.areItemStacksEqual(packetIn.getClickedItem(), itemstack)) {
+                    this.playerEntity.connection.sendPacket(new SPacketConfirmTransaction(packetIn.getWindowId(), packetIn.getActionNumber(), true));
+                    this.playerEntity.isChangingQuantityOnly = true;
+                    this.playerEntity.openContainer.detectAndSendChanges();
+                    this.playerEntity.updateHeldItem();
+                    this.playerEntity.isChangingQuantityOnly = false;
+                }
+                else {
+                    this.pendingTransactions.addKey(this.playerEntity.openContainer.windowId, packetIn.getActionNumber());
+                    this.playerEntity.connection.sendPacket(new SPacketConfirmTransaction(packetIn.getWindowId(), packetIn.getActionNumber(), false));
+                    this.playerEntity.openContainer.setCanCraft(this.playerEntity, false);
+                    final ArrayList<ItemStack> arraylist1 = Lists.newArrayList();
+                    for (int j = 0; j < this.playerEntity.openContainer.inventorySlots.size(); ++j) {
+                        final ItemStack itemstack2 = this.playerEntity.openContainer.inventorySlots.get(j).getStack();
+                        final ItemStack itemstack3 = (itemstack2 != null && itemstack2.stackSize > 0) ? itemstack2 : null;
+                        arraylist1.add(itemstack3);
+                    }
+                    this.playerEntity.updateCraftingInventory(this.playerEntity.openContainer, arraylist1);
+                }
 
-                if (ItemStack.areItemStacksEqual(packetIn.getClickedItem(), itemstack2))
+                if (ItemStack.areItemStacksEqual(packetIn.getClickedItem(), itemstack))
                 {
                     this.playerEntity.connection.sendPacket(new SPacketConfirmTransaction(packetIn.getWindowId(), packetIn.getActionNumber(), true));
                     this.playerEntity.isChangingQuantityOnly = true;
++++ END PATCH
++++ REJECTED PATCH 38
 
                     for (int j = 0; j < this.playerEntity.openContainer.inventorySlots.size(); ++j)
                     {
-                        ItemStack itemstack = ((Slot)this.playerEntity.openContainer.inventorySlots.get(j)).getStack();
-                        ItemStack itemstack1 = itemstack != null && itemstack.stackSize > 0 ? itemstack : null;
+                        ItemStack itemstack2 = ((Slot)this.playerEntity.openContainer.inventorySlots.get(j)).getStack();
+                        ItemStack itemstack1 = itemstack2 != null && itemstack2.stackSize > 0 ? itemstack2 : null;
                         list1.add(itemstack1);
                     }
 
++++ END PATCH
++++ REJECTED PATCH 39
     public void processEnchantItem(CPacketEnchantItem packetIn)
     {
         PacketThreadUtil.checkThreadAndEnqueue(packetIn, this, this.playerEntity.getServerWorld());
+        if (this.playerEntity.isDead) return; // CraftBukkit
         this.playerEntity.markPlayerActive();
 
         if (this.playerEntity.openContainer.windowId == packetIn.getWindowId() && this.playerEntity.openContainer.getCanCraft(this.playerEntity) && !this.playerEntity.isSpectator())
++++ END PATCH
++++ REJECTED PATCH 40
             }
 
             boolean flag1 = packetIn.getSlotId() >= 1 && packetIn.getSlotId() <= 45;
-            boolean flag2 = itemstack == null || itemstack.getItem() != null;
+            // CraftBukkit - Add invalidItems check
+            boolean flag2 = itemstack == null || itemstack.getItem() != null && !NetHandlerPlayServer.invalidItems.contains(Item.getIdFromItem(itemstack.getItem()));
             boolean flag3 = itemstack == null || itemstack.getMetadata() >= 0 && itemstack.stackSize <= 64 && itemstack.stackSize > 0;
-
+            // CraftBukkit start - Call click event
+            if (flag || (flag2 && !ItemStack.areItemStacksEqual(this.playerEntity.inventoryContainer.getSlot(packetIn.getSlotId()).getStack(), packetIn.getStack()))) {
+                final HumanEntity player = this.playerEntity.getBukkitEntity();
+                final InventoryView inventory = new CraftInventoryView(player, player.getInventory(), this.playerEntity.inventoryContainer);
+                final org.bukkit.inventory.ItemStack item = CraftItemStack.asBukkitCopy(packetIn.getStack());
+                InventoryType.SlotType type = InventoryType.SlotType.QUICKBAR;
+                if (flag) {
+                    type = InventoryType.SlotType.OUTSIDE;
+                }
+                else if (packetIn.getSlotId() < 36) {
+                    if (packetIn.getSlotId() >= 5 && packetIn.getSlotId() < 9) {
+                        type = InventoryType.SlotType.ARMOR;
+                    }
+                    else {
+                        type = InventoryType.SlotType.CONTAINER;
+                    }
+                }
+                final InventoryCreativeEvent event = new InventoryCreativeEvent(inventory, type, flag ? -999 : packetIn.getSlotId(), item);
+                this.server.getPluginManager().callEvent(event);
+                itemstack = CraftItemStack.asNMSCopy(event.getCursor());
+                switch (event.getResult()) {
+                    case ALLOW: {
+                        flag2 = (flag3 = true);
+                    }
+                    case DENY: {
+                        if (packetIn.getSlotId() >= 0) {
+                            this.playerEntity.connection.sendPacket(new SPacketSetSlot(this.playerEntity.inventoryContainer.windowId, packetIn.getSlotId(), this.playerEntity.inventoryContainer.getSlot(packetIn.getSlotId()).getStack()));
+                            this.playerEntity.connection.sendPacket(new SPacketSetSlot(-1, -1, null));
+                        }
+                        return;
+                    }
+					default:
+						break;
+                }
+            }
+            // CB end
             if (flag1 && flag2 && flag3)
             {
                 if (itemstack == null)
++++ END PATCH
++++ REJECTED PATCH 41
     public void processConfirmTransaction(CPacketConfirmTransaction packetIn)
     {
         PacketThreadUtil.checkThreadAndEnqueue(packetIn, this, this.playerEntity.getServerWorld());
+        if (this.playerEntity.isDead) return; // CraftBukkit
         Short oshort = (Short)this.pendingTransactions.lookup(this.playerEntity.openContainer.windowId);
 
         if (oshort != null && packetIn.getUid() == oshort.shortValue() && this.playerEntity.openContainer.windowId == packetIn.getWindowId() && !this.playerEntity.openContainer.getCanCraft(this.playerEntity) && !this.playerEntity.isSpectator())
++++ END PATCH
++++ REJECTED PATCH 42
     public void processUpdateSign(CPacketUpdateSign packetIn)
     {
         PacketThreadUtil.checkThreadAndEnqueue(packetIn, this, this.playerEntity.getServerWorld());
+        if (this.playerEntity.isDead) return; // CraftBukkit
         this.playerEntity.markPlayerActive();
         WorldServer worldserver = this.serverController.worldServerForDimension(this.playerEntity.dimension);
         BlockPos blockpos = packetIn.getPosition();
++++ END PATCH
++++ REJECTED PATCH 43
             if (!tileentitysign.getIsEditable() || tileentitysign.getPlayer() != this.playerEntity)
             {
                 this.serverController.logWarning("Player " + this.playerEntity.getName() + " just tried to change non-editable sign");
+                this.sendPacket(tileentity.getUpdatePacket());
                 return;
             }
 
             String[] astring = packetIn.getLines();
 
-            for (int i = 0; i < astring.length; ++i)
-            {
-                tileentitysign.signText[i] = new TextComponentString(TextFormatting.getTextWithoutFormattingCodes(astring[i]));
+            //for (int i = 0; i < astring.length; ++i)
+            //{
+            //   tileentitysign.signText[i] = new TextComponentString(TextFormatting.getTextWithoutFormattingCodes(astring[i]));
+            //}
+            // CB start
+            final Player player = this.server.getPlayer(this.playerEntity);
+            final int x = packetIn.getPosition().getX();
+            final int y = packetIn.getPosition().getY();
+            final int z = packetIn.getPosition().getZ();
+            final String[] lines = new String[4];
+            for (int i = 0; i < astring.length; ++i) {
+                lines[i] = TextFormatting.getTextWithoutFormattingCodes(new TextComponentString(TextFormatting.getTextWithoutFormattingCodes(astring[i])).getUnformattedText());
             }
-
+            final SignChangeEvent event = new SignChangeEvent(player.getWorld().getBlockAt(x, y, z), this.server.getPlayer(this.playerEntity), lines);
+            this.server.getPluginManager().callEvent(event);
+            if (!event.isCancelled()) {
+                System.arraycopy(CraftSign.sanitizeLines(event.getLines()), 0, tileentitysign.signText, 0, 4);
+                tileentitysign.isEditable = false;
+            }
+            // CB end
             tileentitysign.markDirty();
             worldserver.notifyBlockUpdate(blockpos, iblockstate, iblockstate, 3);
         }
++++ END PATCH
++++ REJECTED PATCH 44
     public void processPlayerAbilities(CPacketPlayerAbilities packetIn)
     {
         PacketThreadUtil.checkThreadAndEnqueue(packetIn, this, this.playerEntity.getServerWorld());
-        this.playerEntity.capabilities.isFlying = packetIn.isFlying() && this.playerEntity.capabilities.allowFlying;
+        //this.playerEntity.capabilities.isFlying = packetIn.isFlying() && this.playerEntity.capabilities.allowFlying;
+        // CB start
+        if (this.playerEntity.capabilities.allowFlying && this.playerEntity.capabilities.isFlying != packetIn.isFlying()) {
+            final PlayerToggleFlightEvent event = new PlayerToggleFlightEvent(this.server.getPlayer(this.playerEntity), packetIn.isFlying());
+            this.server.getPluginManager().callEvent(event);
+            if (!event.isCancelled()) {
+                this.playerEntity.capabilities.isFlying = packetIn.isFlying();
+            }
+            else {
+                this.playerEntity.sendPlayerAbilities();
+            }
+        }
+        // CB end
     }
 
     public void processTabComplete(CPacketTabComplete packetIn)
     {
         PacketThreadUtil.checkThreadAndEnqueue(packetIn, this, this.playerEntity.getServerWorld());
+        // CB start
+        if (NetHandlerPlayServer.chatSpamField.addAndGet(this, 10) > 500 && !this.serverController.getPlayerList().canSendCommands(this.playerEntity.getGameProfile())) {
+            this.kickPlayerFromServer("disconnect.spam");
+            return;
+        }
+        // CB end
         List<String> list = Lists.<String>newArrayList();
 
         for (String s : this.serverController.getTabCompletions(this.playerEntity, packetIn.getMessage(), packetIn.getTargetBlock(), packetIn.hasTargetBlock()))
++++ END PATCH
++++ REJECTED PATCH 45
 
                 if (itemstack.getItem() == Items.WRITABLE_BOOK && itemstack.getItem() == itemstack1.getItem())
                 {
+                	itemstack1 = new ItemStack(Items.WRITABLE_BOOK); // CraftBukkit
                     itemstack1.setTagInfo("pages", itemstack.getTagCompound().getTagList("pages", 8));
+                    CraftEventFactory.handleEditBookEvent(playerEntity, itemstack1); // CraftBukkit
                 }
             }
             catch (Exception exception6)
             {
                 LOGGER.error((String)"Couldn\'t handle book info", (Throwable)exception6);
+                this.kickPlayerFromServer("Invalid book data!"); // CraftBukkit
             }
         }
         else if ("MC|BSign".equals(s))
++++ END PATCH
++++ REJECTED PATCH 46
 
                 if (itemstack2.getItem() == Items.WRITABLE_BOOK && itemstack3.getItem() == Items.WRITABLE_BOOK)
                 {
+                	itemstack3 = new ItemStack(Items.WRITABLE_BOOK); // CraftBukkit
                     itemstack3.setTagInfo("author", new NBTTagString(this.playerEntity.getName()));
                     itemstack3.setTagInfo("title", new NBTTagString(itemstack2.getTagCompound().getString("title")));
                     NBTTagList nbttaglist = itemstack2.getTagCompound().getTagList("pages", 8);
++++ END PATCH
++++ REJECTED PATCH 47
 
                     itemstack3.setTagInfo("pages", nbttaglist);
                     itemstack3.setItem(Items.WRITTEN_BOOK);
+                    CraftEventFactory.handleEditBookEvent(playerEntity, itemstack3); // CraftBukkit
                 }
             }
             catch (Exception exception7)
             {
                 LOGGER.error((String)"Couldn\'t sign book", (Throwable)exception7);
+                this.kickPlayerFromServer("Invalid book data!"); // CraftBukkit
             }
         }
         else if ("MC|TrSel".equals(s))
++++ END PATCH
++++ REJECTED PATCH 48
             catch (Exception exception5)
             {
                 LOGGER.error((String)"Couldn\'t select trade", (Throwable)exception5);
+                this.kickPlayerFromServer("Invalid trade data!"); // CraftBukkit
             }
         }
         else if ("MC|AdvCmd".equals(s))
++++ END PATCH
++++ REJECTED PATCH 49
             catch (Exception exception4)
             {
                 LOGGER.error((String)"Couldn\'t set command block", (Throwable)exception4);
+                this.kickPlayerFromServer("Invalid command data!"); // CraftBukkit
             }
         }
         else if ("MC|AutoCmd".equals(s))
++++ END PATCH
++++ REJECTED PATCH 50
             catch (Exception exception3)
             {
                 LOGGER.error((String)"Couldn\'t set command block", (Throwable)exception3);
+                this.kickPlayerFromServer("Invalid command data!"); // CraftBukkit
             }
         }
         else if ("MC|Beacon".equals(s))
++++ END PATCH
++++ REJECTED PATCH 51
                 catch (Exception exception2)
                 {
                     LOGGER.error((String)"Couldn\'t set beacon", (Throwable)exception2);
+                    this.kickPlayerFromServer("Invalid beacon data!"); // CraftBukkit
                 }
             }
         }
++++ END PATCH
++++ REJECTED PATCH 52
             catch (Exception exception1)
             {
                 LOGGER.error((String)"Couldn\'t set structure block", (Throwable)exception1);
+                this.kickPlayerFromServer("Invalid structure data!"); // CraftBukkit
             }
         }
         else if ("MC|PickItem".equals(s))
++++ END PATCH
++++ REJECTED PATCH 53
             catch (Exception exception)
             {
                 LOGGER.error((String)"Couldn\'t pick item", (Throwable)exception);
+                this.kickPlayerFromServer("Invalid item data!"); // CraftBukkit
             }
         }
+        // CB start
+        else if (packetIn.getChannelName().equals("REGISTER")) {
+            final String channels = packetIn.getBufferData().toString(Charsets.UTF_8);
+            String[] split;
+            for (int length = (split = channels.split("\u0000")).length, n = 0; n < length; ++n) {
+                final String channel = split[n];
+                this.getPlayer().addChannel(channel);
+            }
+        }
+        else if (packetIn.getChannelName().equals("UNREGISTER")) {
+            final String channels = packetIn.getBufferData().toString(Charsets.UTF_8);
+            String[] split2;
+            for (int length2 = (split2 = channels.split("\u0000")).length, n2 = 0; n2 < length2; ++n2) {
+                final String channel = split2[n2];
+                this.getPlayer().removeChannel(channel);
+            }
+        }
+        else {
+            final byte[] data = new byte[packetIn.getBufferData().readableBytes()];
+            packetIn.getBufferData().readBytes(data);
+            this.server.getMessenger().dispatchIncomingMessage(this.playerEntity.getBukkitEntity(), packetIn.getChannelName(), data);
+        }
+        // CB end
     }
+    
+    // CraftBukkit start - Add "isDisconnected" method
+    public final boolean isDisconnected() {
+    	return !playerEntity.joining && !this.netManager.isChannelOpen();
+    }
 }
++++ END PATCH
